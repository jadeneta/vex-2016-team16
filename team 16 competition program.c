#pragma config(Sensor, in1,    liftSensor,     sensorPotentiometer)
#pragma config(Sensor, in2,    clawSensor,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightshaft,     sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftshaft,      sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  right_led,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  skill_led,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, hangtoplimit,   sensorTouch)
#pragma config(Sensor, dgtl11, rightauto,      sensorTouch)
#pragma config(Sensor, dgtl12, skill,          sensorTouch)
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightbackwheel, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           rightfrontwheel, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port4,           rightlift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           hang,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftbackwheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftfrontwheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftlift,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#define DEADBAND 20

// Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(300)
#pragma userControlDuration(900)
#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!
#include "slew motor program.c"
int clawtarget = 1000;
const int ARM_LOW = 720;
int armtarget = ARM_LOW;
bool clawhold = false;
bool lifthold = false;
const int CLAW_CLOSE = 2780;
const int ClAW_OPEN = 1200;
const int ARM_HIGH = 2650;
const int TURNRIGHT_90 = 311;
const float SLEW_OFFSET = .4;

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them
// in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton() {
	SensorValue[skill_led] = 0;
	SensorValue[right_led] = 0;
	if(SensorValue[skill] == 1) SensorValue[skill_led] = 1;
	else if (SensorValue[rightauto] == 1) SensorValue[right_led] = 1;
	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

int min(int a, int b) {
	if (a > b)
		return b;
	return a;
}

int max(int a, int b) {
	if (a > b)
		return a;
	return b;
}

/////////////////////////////////////////////////////////////////////////////////////////
//                                                                                     /
//                                 Autonomous Task                                    /
//                                                                                   /
// This task is used to control your robot during the autonomous phase of a VEX     /
// Competition.                 n
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task claw_Control() {
	while (true) {
		if(clawtarget < CLAW_OPEN) clawtarget = CLAW_OPEN;
		if(clawtarget > CLAW_CLOSE) clawtarget = CLAW_CLOSE;
		int currentvalue = SensorValue[clawSensor];
		int clawerror = clawtarget - abs(currentvalue);
		int clawpower = clawerror / 5;
		if (clawpower > 127) {
			clawpower = 127;
		}
		if (clawpower < -127)
		{
			clawpower = -127;
		}
		if (abs(clawpower) < 20)
		{
			clawpower = 0;
		}
		motorReq[claw] = clawpower;

		wait1Msec(MOTOR_TASK_DELAY);
	}
}
task arm_Control() {
	int arm = 0;

	int armerror = 0;

	while (true) {
		if(lifthold)
		{
			if (armtarget < ARM_LOW)
			{
				armtarget = ARM_LOW;
			}
			if(armtarget > ARM_HIGH)
			{
				armtarget = ARM_HIGH;
			}
			int currentvalue = SensorValue[liftSensor];
			armerror = armtarget - abs(currentvalue);
			arm = armerror / 5;
			if (arm > 127) {
				arm = 127;
			}
			if (abs(arm) < 20)
				arm = 0;
			if (arm < -60)
				arm = -60;
			motorReq[rightlift] = arm;
			motorReq[leftlift] = arm;
		}
		wait1Msec(MOTOR_TASK_DELAY);
	}
}
void autoleft();
void autoskill();
void autoright();
void auto();
void moveforward_right(int forward) {

	motorReq[rightfrontwheel] = -forward;
	motorReq[rightbackwheel] = -forward;
}
void moveforward_left(int forward) {
	motorReq[leftfrontwheel] = forward;
	motorReq[leftbackwheel] = forward;
}
void moveforward(int forward) {
	moveforward_left(forward);
	moveforward_right(forward);
}
void movebackward_left(int backward) {
	motorReq[leftfrontwheel] = -backward;
	motorReq[leftbackwheel] = -backward;
}
void movebackward_right(int backward) {
	motorReq[rightfrontwheel] = backward;
	motorReq[rightbackwheel] = backward;
}
void movebackward(int backward) {
	movebackward_right(backward);
	movebackward_left(backward);
}
void turnleft_left(int left) {
	motorReq[leftfrontwheel] = -left;
	motorReq[leftbackwheel] = -left;
}
void turnleft_right(int left) {
	motorReq[rightfrontwheel] = -left;
	motorReq[rightbackwheel] = -left;
}
void turnleft(int left) {
	turnleft_right(left);
	turnleft_left(left);
}
void turnright_left(int right) {
	motorReq[leftfrontwheel] = right;
	motorReq[leftbackwheel] = right;
}
void turnright_right(int right) {
	motorReq[rightfrontwheel] = right;
	motorReq[rightbackwheel] = right;
}
void turnright(int right) {
	turnright_right(right);
	turnright_left(right);
}
void closeclaw() { clawtarget = CLAW_CLOSE; }
void openclaw() { clawtarget = CLAW_OPEN; }
void liftarm() { armtarget = ARM_HIGH; }
void droparm() { armtarget = ARM_LOW; }
void setArmPower(int speed) {
	// motorReq[leftclaw] = speed;
	motorReq[claw] = speed;
}

void moveForwardWithSensor(int rotations) {
	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueRight = 0;
	int lastSensorValueLeft = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	int buffer = 10;
	float slowdown = .98;



	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET)	 {
		int leftpower = 0;
		int rightpower = 0;

		if (SensorValue[leftshaft] < rotations) {

			int error = rotations - SensorValue[leftshaft];

			leftpower = error / 4;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(127, leftpower)
		}
		if (SensorValue[rightshaft] < rotations) {

			int error = rotations - SensorValue[rightshaft];

			rightpower = error / 4;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(127, rightpower)
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}

		moveforward_left(leftpower * leftmultiplier);
		moveforward_right(rightpower * rightmultiplier );
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
		wait1Msec(MOTOR_TASK_DELAY);
	}
	moveforward(0);
}
void turnRightWithSensor(int rotations) {
	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_rightpower = 25;
	int min_leftpower = 25;
	int lastSensorValueRight = 0;
	int lastSensorValueLeft = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	float slowdown = .98;
	int buffer = 10;
	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET) {
		int leftpower = 0;
		int rightpower = 0;
		if (abs(SensorValue[leftshaft]) < rotations) {

			int error = rotations - abs(SensorValue[leftshaft]);

			leftpower = error / 4;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(127, leftpower)
		}
		if (abs(SensorValue[rightshaft]) < rotations) {

			int error = rotations - abs(SensorValue[rightshaft]);

			rightpower = error / 4;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(127, rightpower)
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}
		turnright_left(leftpower * leftmultiplier);
		turnright_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
		wait1Msec(MOTOR_TASK_DELAY);
	}
	turnright(0);
}
void waitforarmheight(int height)
{
	while (SensorValue[liftSensor] < height)
		wait1Msec(MOTOR_TASK_DELAY);
}

void moveBackwardWithSensor(int rotations) {
	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueLeft = 0;
	int lastSensorValueRight = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	float slowdown = .98;
	int buffer = 10;
	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET) {
		int leftpower = 0;
		int rightpower = 0;
		if (abs(SensorValue[leftshaft]) < rotations) {

			int error = rotations - abs(SensorValue[leftshaft]);

			leftpower = error / 4;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(127, leftpower)
		}
		if (abs(SensorValue[rightshaft]) < rotations) {

			int error = rotations - abs(SensorValue[rightshaft]);

			rightpower = error / 4;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(127, rightpower)
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}
		movebackward_left(leftpower * leftmultiplier);
		movebackward_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
		wait1Msec(MOTOR_TASK_DELAY);
	}
	movebackward(0);
}
void turnLeftWithSensor(int rotations) {
	SensorValue[leftshaft] = 0;
	SensorValue[rightshaft] = 0;
	int min_leftpower = 25;
	int min_rightpower = 25;
	int lastSensorValueLeft = 0;
	int lastSensorValueRight = 0;
	int leftmultiplier = 1;
	int rightmultiplier = 1;
	float slowdown = .98;
	int buffer = 10;
	while ((abs(SensorValue[leftshaft])+ abs(SensorValue[rightshaft]))/2 < rotations * SLEW_OFFSET) {
		int leftpower = 0;
		int rightpower = 0;
		if (abs(SensorValue[leftshaft]) < rotations) {

			int error = rotations - abs(SensorValue[leftshaft]);

			leftpower = error / 4;
			if (abs(SensorValue[leftshaft]) == lastSensorValueLeft)
				min_leftpower += 5;
			if (leftpower < min_leftpower)
				leftpower = min_leftpower;
			leftpower = min(127, leftpower)
		}
		if (abs(SensorValue[rightshaft]) < rotations) {

			int error = rotations - abs(SensorValue[rightshaft]);

			rightpower = error / 4;
			if (abs(SensorValue[rightshaft]) == lastSensorValueRight)
				min_rightpower += 5;
			if (rightpower < min_rightpower)
				rightpower = min_rightpower;
			rightpower = min(127, rightpower)
		}
		// left sensor moving too fast
		if (abs(SensorValue[leftshaft]) > abs(SensorValue[rightshaft]) + buffer)
		{
			rightmultiplier = 1;
			leftmultiplier = leftmultiplier * slowdown;
		}
		else if (abs(SensorValue[rightshaft]) > abs(SensorValue[leftshaft]) + buffer)
		{
			leftmultiplier = 1;
			rightmultiplier = rightmultiplier * slowdown;
			//right sensor moving too fast

		}
		else
		{
			rightmultiplier = 1;
			leftmultiplier = 1;
		}
		turnleft_left(leftpower * leftmultiplier);
		turnleft_right(rightpower * rightmultiplier);
		lastSensorValueLeft = abs(SensorValue[leftshaft]);
		lastSensorValueRight = abs(SensorValue[rightshaft]);
		wait1Msec(MOTOR_TASK_DELAY);
	}
	turnleft(0);
}
task autonomous() {
	startTask(MotorSlewRateTask);
	startTask(arm_Control);
	startTask(claw_Control);

	auto();

	stopTask(MotorSlewRateTask);
	stopTask(arm_Control);
	stopTask(claw_Control);
}
void auto() {
	droparm();
	clawhold = true;
	lifthold = true;
	if (SensorValue[skill] == 1) {
		autoskill();
		} else if (SensorValue[rightauto] == 1) {
		autoright();
		} else {
		autoleft();
	}
}




#include "left auto.c"
#include "skill auto.c"
#include "right auto.c"




/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a
// VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol() {
	// User control code here, inside the loop
	startTask(arm_Control);
	startTask(claw_Control);
	startTask(MotorSlewRateTask);
	int clawOpenSpeed = 127;
	int clawCloseSpeed = 127;
	int clawGrabSpeed = 100;
	bool stallhang = false;
	lifthold = false;
	SensorValue[leftshaft] = 0;
	SensorValue[skill] = 0;
	SensorValue[rightauto] = 0;
	int clawspeed = 0;
	int arm = 0;
	int armerror = 0;
	armtarget = 40;
	while (true) {
		int clawSensorValue = SensorValue[clawSensor];
		int liftSensorValue = SensorValue[liftSensor];
		int backwheelspeed = 0;
		int leftBspeed = 0;
		int leftFspeed = 0;
		int rightFspeed = 0;
		int rightBspeed = 0;
		if (vexRT[Btn5U] == 1) {
			auto();
		}

		// Turn left-right
		if (abs(vexRT[Ch4]) > DEADBAND) {
			leftBspeed = vexRT[Ch4] / 2;
			leftFspeed = vexRT[Ch4] / 2;
			rightBspeed = vexRT[Ch4] / 2;
			rightFspeed = vexRT[Ch4] / 2;
			} else {
			// Move Forward/Backward
			if (abs(vexRT[Ch2]) > DEADBAND) {
				leftFspeed = vexRT[Ch2];
				leftBspeed = vexRT[Ch2];
				rightFspeed = -vexRT[Ch2];
				rightBspeed = -vexRT[Ch2];
			}


		}
/*		//if(vexRT[Btn6U] == 1)
		//{
			//stallhang = true;
		//}
		//else if(vexRT[Btn6D] == 1)
		//{
		//	stallhang = false;
		//}

		//if(vexRT[Btn7U] == 1)
		//{
			//motorReq[hang] = 127;

			if(SensorValue[hangtoplimit] == 1)
			{
				motorReq[hang] = 0;
			}
		} else if(vexRT[Btn7D] == 1)
		{
			motorReq[hang] = -127;

		} else
		{
			if(stallhang)
			{
				motorReq[hang] = 30;
			} else
			{
				motorReq[hang] = 0;
			}
		}
*/
		if(vexRT[Btn8U] == 1)
		{
			SensorValue[leftshaft] = 0;
			SensorValue[rightshaft] = 0;
		}
		// Close Claw
		if (vexRT[Btn8UXmtr2] == 1) {
			clawtarget = min(CLAW_CLOSE, clawtarget + 25);
			clawhold = false;
		}
		// Open Claw
		else if (vexRT[Btn8DXmtr2] == 1) {
			clawtarget = max(ClAW_OPEN, clawtarget - 25);
			clawhold = false;

			} else {
			// Grab and Hold
			if (vexRT[Btn6UXmtr2] == 1) {
				clawtarget = CLAW_CLOSE;
				clawhold = true;
			}
			if (!clawhold) {
				clawspeed = 0;
			}
		}

		// Lift
		if (vexRT[Btn5UXmtr2] == 1) {
			lifthold = true;
			armtarget = 1500;
		}

		if (vexRT[Btn7UXmtr2] == 1) {
			// Srop Arm when switch activated
			armtarget = min(ARM_HIGH, armtarget + 30);
			lifthold = true;
		}

		// Drop Lift
		else if (vexRT[Btn7DXmtr2] == 1) {
			armtarget = max(ARM_LOW, armtarget - 25);
			lifthold = true;
		}

		else {
			arm = 0;
		}

		if (vexRT[Btn5DXmtr2] == 1) {
			arm = 0;
			lifthold = false;
		}

		// keeps lift up a little to move around
		/*
		if (SensorValue[touch] == 1) {
		if (arm > 0) {
		arm = 0;
		}
		claw = clawOpenSpeed;
		clawhold = false;
		lifthold = false;
		}
		if (SensorValue[bumper] == 1) {
		if (arm < 0) {
		arm = 0;
		}
		SensorValue[leftshaft] = 0;
		}
		*/

		// arm Sensor max value 2700(top) min value 900(bottom)
		motorReq[leftbackwheel] = leftBspeed; // claw closed 2870 claw middle 1250
		motorReq[leftfrontwheel] = leftFspeed;
		motorReq[rightfrontwheel] = rightFspeed;
		motorReq[rightbackwheel] = rightBspeed;
		// motorReq[bottomhang] = hang;
		// motorReq[tophang] = hang;


		wait1Msec(MOTOR_TASK_DELAY);
	}
}
